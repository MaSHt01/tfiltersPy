<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tfilterspy.state_estimation package &mdash; tfilterspy 1.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            tfilterspy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_usage.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_index.html">Real World Use CasesğŸ¢</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">tfilterspy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">tfilterspy.state_estimation package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/TFiltersPy.state_estimation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tfilterspy-state-estimation-package">
<h1>tfilterspy.state_estimation package<a class="headerlink" href="#tfilterspy-state-estimation-package" title="Permalink to this heading">ïƒ</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">ïƒ</a></h2>
</section>
<section id="tfilterspy-state-estimation-linear-filters-module">
<h2>tfilterspy.state_estimation.linear_filters module<a class="headerlink" href="#tfilterspy-state-estimation-linear-filters-module" title="Permalink to this heading">ïƒ</a></h2>
</section>
<section id="tfilterspy-state-estimation-nonlinear-filters-module">
<h2>tfilterspy.state_estimation.nonlinear_filters module<a class="headerlink" href="#tfilterspy-state-estimation-nonlinear-filters-module" title="Permalink to this heading">ïƒ</a></h2>
</section>
<section id="tfilterspy-state-estimation-particle-filters-module">
<h2>tfilterspy.state_estimation.particle_filters module<a class="headerlink" href="#tfilterspy-state-estimation-particle-filters-module" title="Permalink to this heading">ïƒ</a></h2>
<span class="target" id="module-tfilterspy.state_estimation.particle_filters"></span><dl class="py class">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tfilterspy.state_estimation.particle_filters.</span></span><span class="sig-name descname"><span class="pre">DaskParticleFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_transition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_noise_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_particles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimation_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'residual_analysis'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Bases: <a class="reference internal" href="TFiltersPy.utils.html#tfilterspy.utils.optimisation_utils.ParameterEstimator" title="tfilterspy.utils.optimisation_utils.ParameterEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterEstimator</span></code></a></p>
<p>A multivariate, scalable particle filter using Dask. Inherits parameter estimation
methods from ParameterEstimator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter.estimate_state">
<span class="sig-name descname"><span class="pre">estimate_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.estimate_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter.estimate_state" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 5: State Estimation. Compute the state estimate as the weighted average of particles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter.predict" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 2: Prediction. Propagate each particle using the state transition model plus
Gaussian process noise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter.resample" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 4: Resampling. Multinomial resampling to refocus on high-probability particles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter.run_filter">
<span class="sig-name descname"><span class="pre">run_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurements</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.run_filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter.run_filter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>This method is required for parameter estimation routines. It should run the filter
over a sequence of measurements and return both the state estimates and the residuals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurements</strong> (<em>da.Array</em>) â€“ Array of measurements over time, shape (n_timesteps, n_obs).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Filtered state estimates, shape (n_timesteps, n_state).
residuals (da.Array): Residuals (measurement - predicted_measurement), same shape as measurements.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>state_estimates (da.Array)</p>
</dd>
</dl>
<p>For this simple example, we run the filter sequentially over the measurements.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter.step" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 6: Iteration. Run one full filter cycle: predict, update, resample, and state estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurement</strong> (<em>np.ndarray</em>) â€“ The observed measurement.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The estimated state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.particle_filters.DaskParticleFilter.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.particle_filters.DaskParticleFilter.update" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 3: Measurement Update. Update particle weights based on the likelihood
of the observed measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurement</strong> (<em>np.ndarray</em>) â€“ The observed measurement.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-tfilterspy.state_estimation">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-tfilterspy.state_estimation" title="Permalink to this heading">ïƒ</a></h2>
<p>State Estimation submodule containing implementations for Kalman Filters,
Nonlinear Filters, and Particle Filters.</p>
<dl class="py class">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskKalmanFilter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tfilterspy.state_estimation.</span></span><span class="sig-name descname"><span class="pre">DaskKalmanFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_transition_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_noise_cov</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise_cov</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimation_strategy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'residual_analysis'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/linear_filters.html#DaskKalmanFilter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskKalmanFilter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Bases: <a class="reference internal" href="TFiltersPy.utils.html#tfilterspy.utils.optimisation_utils.ParameterEstimator" title="tfilterspy.utils.optimisation_utils.ParameterEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterEstimator</span></code></a></p>
<p>Dask-based implementation of a Kalman Filter that supports distributed computing for
large datasets. This class extends the ParameterEstimator to estimate the process
noise covariance (Q) and observation noise covariance (R) while applying Kalman Filtering
on incoming measurements.</p>
<p>The Kalman Filter is a recursive algorithm that estimates the state of a linear dynamic
system from noisy measurements. This implementation leverages Dask to scale computations
across distributed systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_transition_matrix</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_features</em><em>, </em><em>n_features</em><em>)</em>) â€“ The state transition matrix (F) representing how the system evolves between states.</p></li>
<li><p><strong>observation_matrix</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>, </em><em>n_features</em><em>)</em>) â€“ The observation matrix (H) that maps the true state space into the observed space.</p></li>
<li><p><strong>process_noise_cov</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_features</em><em>, </em><em>n_features</em><em>)</em>) â€“ Covariance matrix (Q) representing the process noise.</p></li>
<li><p><strong>observation_noise_cov</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_observations</em><em>, </em><em>n_observations</em><em>)</em>) â€“ Covariance matrix (R) representing the observation noise.</p></li>
<li><p><strong>initial_state</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) â€“ Initial state vector (x0) of the system.</p></li>
<li><p><strong>initial_covariance</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_features</em><em>, </em><em>n_features</em><em>)</em>) â€“ Initial state covariance matrix (P0), representing initial uncertainty in the state.</p></li>
<li><p><strong>estimation_strategy</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default=&quot;residual_analysis&quot;</em>) â€“ The strategy for estimating Q and R. Can be one of:
- â€œresidual_analysisâ€
- â€œmleâ€
- â€œcross_validationâ€
- â€œadaptive_filteringâ€</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> â€“ If matrix dimensions do not conform to Kalman Filter requirements.</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Welch, G., &amp; Bishop, G. (1995). An Introduction to the Kalman Filter.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskKalmanFilter.estimate_parameters">
<span class="sig-name descname"><span class="pre">estimate_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurements</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/tfilterspy/state_estimation/linear_filters.html#DaskKalmanFilter.estimate_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskKalmanFilter.estimate_parameters" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Estimate process (Q) and observation (R) noise covariances using the specified strategy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurements</strong> (<em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_timesteps</em><em>, </em><em>n_observations</em><em>)</em>) â€“ Observed measurements over time.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Q</strong> (<em>da.Array, shape (n_features, n_features)</em>) â€“ Estimated process noise covariance matrix.</p></li>
<li><p><strong>R</strong> (<em>da.Array, shape (n_features, n_features)</em>) â€“ Estimated observation noise covariance matrix.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This method calls the appropriate estimation strategy from the parent class.</p></li>
<li><p>The available strategies include residual analysis, MLE, cross-validation,
and adaptive filtering.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskKalmanFilter.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tfilterspy.state_estimation.DaskKalmanFilter" title="tfilterspy.state_estimation.linear_filters.DaskKalmanFilter"><span class="pre">DaskKalmanFilter</span></a></span></span><a class="reference internal" href="_modules/tfilterspy/state_estimation/linear_filters.html#DaskKalmanFilter.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskKalmanFilter.fit" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Prepare the Kalman Filter by storing the measurements as a Dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>np.ndarray</em><em> or </em><em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_timesteps</em><em>, </em><em>n_observations</em><em>)</em>) â€“ Array of measurements over time.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> â€“ The fitted Kalman Filter instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tfilterspy.state_estimation.DaskKalmanFilter" title="tfilterspy.state_estimation.DaskKalmanFilter">DaskKalmanFilter</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> â€“ If the input measurements are not 2-dimensional.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskKalmanFilter.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Array</span></span></span><a class="reference internal" href="_modules/tfilterspy/state_estimation/linear_filters.html#DaskKalmanFilter.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskKalmanFilter.predict" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Perform state estimation over all time steps using the Kalman Filter algorithm.</p>
<p>This method constructs a Dask computation graph to process the entire measurement
sequence in parallel using delayed execution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>state_estimates</strong> â€“ The estimated state at each time step.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>da.Array, shape (n_timesteps, n_features)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The Kalman Filter operates in two steps: prediction and update.</p></li>
<li><p>Predictions are made using the state transition matrix F.</p></li>
<li><p>Updates are performed using the observation matrix H and Kalman Gain K.</p></li>
<li><p>This method leverages Dask to parallelize the filter process over multiple time steps.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskKalmanFilter.run_filter">
<span class="sig-name descname"><span class="pre">run_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurements</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/tfilterspy/state_estimation/linear_filters.html#DaskKalmanFilter.run_filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskKalmanFilter.run_filter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Apply the Kalman Filter on measurements to compute state estimates and residuals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurements</strong> (<em>da.Array</em><em>, </em><em>shape</em><em> (</em><em>n_timesteps</em><em>, </em><em>n_observations</em><em>)</em>) â€“ Observed measurements over time.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>state_estimates</strong> (<em>da.Array, shape (n_timesteps, n_features)</em>) â€“ Estimated states over the measurement timeline.</p></li>
<li><p><strong>residuals</strong> (<em>da.Array, shape (n_timesteps, n_observations)</em>) â€“ Difference between observed and predicted measurements (innovations).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is used by parameter estimation strategies to compute residuals.</p></li>
<li><p>Residuals are used for adaptive filtering and cross-validation strategies.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskNonLinearKalmanFilter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tfilterspy.state_estimation.</span></span><span class="sig-name descname"><span class="pre">DaskNonLinearKalmanFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimation_strategy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'residual_analysis'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/nonlinear_filters.html#DaskNonLinearKalmanFilter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskNonLinearKalmanFilter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Bases: <a class="reference internal" href="TFiltersPy.utils.html#tfilterspy.utils.optimisation_utils.ParameterEstimator" title="tfilterspy.utils.optimisation_utils.ParameterEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterEstimator</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tfilterspy.state_estimation.</span></span><span class="sig-name descname"><span class="pre">DaskParticleFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_transition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_noise_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_particles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimation_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'residual_analysis'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Bases: <a class="reference internal" href="TFiltersPy.utils.html#tfilterspy.utils.optimisation_utils.ParameterEstimator" title="tfilterspy.utils.optimisation_utils.ParameterEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterEstimator</span></code></a></p>
<p>A multivariate, scalable particle filter using Dask. Inherits parameter estimation
methods from ParameterEstimator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter.estimate_state">
<span class="sig-name descname"><span class="pre">estimate_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.estimate_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter.estimate_state" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 5: State Estimation. Compute the state estimate as the weighted average of particles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter.predict" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 2: Prediction. Propagate each particle using the state transition model plus
Gaussian process noise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter.resample" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 4: Resampling. Multinomial resampling to refocus on high-probability particles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter.run_filter">
<span class="sig-name descname"><span class="pre">run_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurements</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.run_filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter.run_filter" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>This method is required for parameter estimation routines. It should run the filter
over a sequence of measurements and return both the state estimates and the residuals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurements</strong> (<em>da.Array</em>) â€“ Array of measurements over time, shape (n_timesteps, n_obs).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Filtered state estimates, shape (n_timesteps, n_state).
residuals (da.Array): Residuals (measurement - predicted_measurement), same shape as measurements.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>state_estimates (da.Array)</p>
</dd>
</dl>
<p>For this simple example, we run the filter sequentially over the measurements.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter.step" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 6: Iteration. Run one full filter cycle: predict, update, resample, and state estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurement</strong> (<em>np.ndarray</em>) â€“ The observed measurement.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The estimated state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tfilterspy.state_estimation.DaskParticleFilter.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tfilterspy/state_estimation/particle_filters.html#DaskParticleFilter.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tfilterspy.state_estimation.DaskParticleFilter.update" title="Permalink to this definition">ïƒ</a></dt>
<dd><p>Step 3: Measurement Update. Update particle weights based on the likelihood
of the observed measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>measurement</strong> (<em>np.ndarray</em>) â€“ The observed measurement.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Thabang Mashinin-Sekhoto, Lebogang Mashinini-Sekhoto, Palesa Mashinini-Sekhoto.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>